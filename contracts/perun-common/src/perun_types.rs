// Generated by Molecule 0.7.3

use molecule :: prelude :: * ;
# [derive (Clone)] pub struct Address (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Address { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Address { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Address { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Address { fn default () -> Self { let v : Vec < u8 > = vec ! [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; Address :: new_unchecked (v . into ()) } } impl Address { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn nth16 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (16 .. 17)) } pub fn nth17 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (17 .. 18)) } pub fn nth18 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (18 .. 19)) } pub fn nth19 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (19 .. 20)) } pub fn nth20 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (20 .. 21)) } pub fn nth21 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (21 .. 22)) } pub fn nth22 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (22 .. 23)) } pub fn nth23 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (23 .. 24)) } pub fn nth24 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (24 .. 25)) } pub fn nth25 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (25 .. 26)) } pub fn nth26 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (26 .. 27)) } pub fn nth27 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (27 .. 28)) } pub fn nth28 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (28 .. 29)) } pub fn nth29 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (29 .. 30)) } pub fn nth30 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (30 .. 31)) } pub fn nth31 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (31 .. 32)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> AddressReader < 'r > { AddressReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Address { type Builder = AddressBuilder ; const NAME : & 'static str = "Address" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Address (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { AddressReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { AddressReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () , self . nth16 () , self . nth17 () , self . nth18 () , self . nth19 () , self . nth20 () , self . nth21 () , self . nth22 () , self . nth23 () , self . nth24 () , self . nth25 () , self . nth26 () , self . nth27 () , self . nth28 () , self . nth29 () , self . nth30 () , self . nth31 () ,]) } }
# [derive (Clone , Copy)] pub struct AddressReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for AddressReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for AddressReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for AddressReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > AddressReader < 'r > { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn nth16 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [16 .. 17]) } pub fn nth17 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [17 .. 18]) } pub fn nth18 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [18 .. 19]) } pub fn nth19 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [19 .. 20]) } pub fn nth20 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [20 .. 21]) } pub fn nth21 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [21 .. 22]) } pub fn nth22 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [22 .. 23]) } pub fn nth23 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [23 .. 24]) } pub fn nth24 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [24 .. 25]) } pub fn nth25 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [25 .. 26]) } pub fn nth26 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [26 .. 27]) } pub fn nth27 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [27 .. 28]) } pub fn nth28 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [28 .. 29]) } pub fn nth29 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [29 .. 30]) } pub fn nth30 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [30 .. 31]) } pub fn nth31 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [31 .. 32]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for AddressReader < 'r > { type Entity = Address ; const NAME : & 'static str = "AddressReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { AddressReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
pub struct AddressBuilder (pub (crate) [Byte ; 32]) ; impl :: core :: fmt :: Debug for AddressBuilder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for AddressBuilder { fn default () -> Self { AddressBuilder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl AddressBuilder { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn set (mut self , v : [Byte ; 32]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } pub fn nth8 (mut self , v : Byte) -> Self { self . 0 [8] = v ; self } pub fn nth9 (mut self , v : Byte) -> Self { self . 0 [9] = v ; self } pub fn nth10 (mut self , v : Byte) -> Self { self . 0 [10] = v ; self } pub fn nth11 (mut self , v : Byte) -> Self { self . 0 [11] = v ; self } pub fn nth12 (mut self , v : Byte) -> Self { self . 0 [12] = v ; self } pub fn nth13 (mut self , v : Byte) -> Self { self . 0 [13] = v ; self } pub fn nth14 (mut self , v : Byte) -> Self { self . 0 [14] = v ; self } pub fn nth15 (mut self , v : Byte) -> Self { self . 0 [15] = v ; self } pub fn nth16 (mut self , v : Byte) -> Self { self . 0 [16] = v ; self } pub fn nth17 (mut self , v : Byte) -> Self { self . 0 [17] = v ; self } pub fn nth18 (mut self , v : Byte) -> Self { self . 0 [18] = v ; self } pub fn nth19 (mut self , v : Byte) -> Self { self . 0 [19] = v ; self } pub fn nth20 (mut self , v : Byte) -> Self { self . 0 [20] = v ; self } pub fn nth21 (mut self , v : Byte) -> Self { self . 0 [21] = v ; self } pub fn nth22 (mut self , v : Byte) -> Self { self . 0 [22] = v ; self } pub fn nth23 (mut self , v : Byte) -> Self { self . 0 [23] = v ; self } pub fn nth24 (mut self , v : Byte) -> Self { self . 0 [24] = v ; self } pub fn nth25 (mut self , v : Byte) -> Self { self . 0 [25] = v ; self } pub fn nth26 (mut self , v : Byte) -> Self { self . 0 [26] = v ; self } pub fn nth27 (mut self , v : Byte) -> Self { self . 0 [27] = v ; self } pub fn nth28 (mut self , v : Byte) -> Self { self . 0 [28] = v ; self } pub fn nth29 (mut self , v : Byte) -> Self { self . 0 [29] = v ; self } pub fn nth30 (mut self , v : Byte) -> Self { self . 0 [30] = v ; self } pub fn nth31 (mut self , v : Byte) -> Self { self . 0 [31] = v ; self } } impl molecule :: prelude :: Builder for AddressBuilder { type Entity = Address ; const NAME : & 'static str = "AddressBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; writer . write_all (self . 0 [16] . as_slice ()) ? ; writer . write_all (self . 0 [17] . as_slice ()) ? ; writer . write_all (self . 0 [18] . as_slice ()) ? ; writer . write_all (self . 0 [19] . as_slice ()) ? ; writer . write_all (self . 0 [20] . as_slice ()) ? ; writer . write_all (self . 0 [21] . as_slice ()) ? ; writer . write_all (self . 0 [22] . as_slice ()) ? ; writer . write_all (self . 0 [23] . as_slice ()) ? ; writer . write_all (self . 0 [24] . as_slice ()) ? ; writer . write_all (self . 0 [25] . as_slice ()) ? ; writer . write_all (self . 0 [26] . as_slice ()) ? ; writer . write_all (self . 0 [27] . as_slice ()) ? ; writer . write_all (self . 0 [28] . as_slice ()) ? ; writer . write_all (self . 0 [29] . as_slice ()) ? ; writer . write_all (self . 0 [30] . as_slice ()) ? ; writer . write_all (self . 0 [31] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Address :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Participants (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Participants { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Participants { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Participants { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; write ! (f , "{}" , self . nth0 ()) ? ; write ! (f , ", {}" , self . nth1 ()) ? ; write ! (f , "]") } } impl :: core :: default :: Default for Participants { fn default () -> Self { let v : Vec < u8 > = vec ! [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; Participants :: new_unchecked (v . into ()) } } impl Participants { pub const TOTAL_SIZE : usize = 64 ; pub const ITEM_SIZE : usize = 32 ; pub const ITEM_COUNT : usize = 2 ; pub fn nth0 (& self) -> Address { Address :: new_unchecked (self . 0 . slice (0 .. 32)) } pub fn nth1 (& self) -> Address { Address :: new_unchecked (self . 0 . slice (32 .. 64)) } pub fn as_reader < 'r > (& 'r self) -> ParticipantsReader < 'r > { ParticipantsReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Participants { type Builder = ParticipantsBuilder ; const NAME : & 'static str = "Participants" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Participants (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ParticipantsReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ParticipantsReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () ,]) } }
# [derive (Clone , Copy)] pub struct ParticipantsReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ParticipantsReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ParticipantsReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ParticipantsReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; write ! (f , "{}" , self . nth0 ()) ? ; write ! (f , ", {}" , self . nth1 ()) ? ; write ! (f , "]") } } impl < 'r > ParticipantsReader < 'r > { pub const TOTAL_SIZE : usize = 64 ; pub const ITEM_SIZE : usize = 32 ; pub const ITEM_COUNT : usize = 2 ; pub fn nth0 (& self) -> AddressReader < 'r > { AddressReader :: new_unchecked (& self . as_slice () [0 .. 32]) } pub fn nth1 (& self) -> AddressReader < 'r > { AddressReader :: new_unchecked (& self . as_slice () [32 .. 64]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for ParticipantsReader < 'r > { type Entity = Participants ; const NAME : & 'static str = "ParticipantsReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ParticipantsReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
pub struct ParticipantsBuilder (pub (crate) [Address ; 2]) ; impl :: core :: fmt :: Debug for ParticipantsBuilder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for ParticipantsBuilder { fn default () -> Self { ParticipantsBuilder ([Address :: default () , Address :: default () ,]) } } impl ParticipantsBuilder { pub const TOTAL_SIZE : usize = 64 ; pub const ITEM_SIZE : usize = 32 ; pub const ITEM_COUNT : usize = 2 ; pub fn set (mut self , v : [Address ; 2]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Address) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Address) -> Self { self . 0 [1] = v ; self } } impl molecule :: prelude :: Builder for ParticipantsBuilder { type Entity = Participants ; const NAME : & 'static str = "ParticipantsBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Participants :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Bytes (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Bytes { fn default () -> Self { let v : Vec < u8 > = vec ! [0 , 0 , 0 , 0 ,] ; Bytes :: new_unchecked (v . into ()) } } impl Bytes { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . 0 . slice (molecule :: NUMBER_SIZE ..) } pub fn as_reader < 'r > (& 'r self) -> BytesReader < 'r > { BytesReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Bytes { type Builder = BytesBuilder ; const NAME : & 'static str = "Bytes" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Bytes (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct BytesReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > BytesReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ByteReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ByteReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn raw_data (& self) -> & 'r [u8] { & self . as_slice () [molecule :: NUMBER_SIZE ..] } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesReader < 'r > { type Entity = Bytes ; const NAME : & 'static str = "BytesReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Debug , Default)] pub struct BytesBuilder (pub (crate) Vec < Byte >) ; impl BytesBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Byte >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Byte) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Byte) -> Option < Byte > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for BytesBuilder { type Entity = Bytes ; const NAME : & 'static str = "BytesBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Bytes :: new_unchecked (inner . into ()) } }
pub struct BytesIterator (Bytes , usize , usize) ; impl :: core :: iter :: Iterator for BytesIterator { type Item = Byte ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for BytesIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Bytes { type Item = Byte ; type IntoIter = BytesIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; BytesIterator (self , 0 , len) } }
# [derive (Clone)] pub struct ChannelParameters (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ChannelParameters { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ChannelParameters { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ChannelParameters { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "participants" , self . participants ()) ? ; write ! (f , ", {}: {}" , "nonce" , self . nonce ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for ChannelParameters { fn default () -> Self { let v : Vec < u8 > = vec ! [80 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 76 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; ChannelParameters :: new_unchecked (v . into ()) } } impl ChannelParameters { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn participants (& self) -> Participants { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Participants :: new_unchecked (self . 0 . slice (start .. end)) } pub fn nonce (& self) -> Bytes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } else { Bytes :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ChannelParametersReader < 'r > { ChannelParametersReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ChannelParameters { type Builder = ChannelParametersBuilder ; const NAME : & 'static str = "ChannelParameters" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ChannelParameters (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ChannelParametersReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ChannelParametersReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . participants (self . participants ()) . nonce (self . nonce ()) } }
# [derive (Clone , Copy)] pub struct ChannelParametersReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ChannelParametersReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ChannelParametersReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ChannelParametersReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "participants" , self . participants ()) ? ; write ! (f , ", {}: {}" , "nonce" , self . nonce ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ChannelParametersReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn participants (& self) -> ParticipantsReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; ParticipantsReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn nonce (& self) -> BytesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ChannelParametersReader < 'r > { type Entity = ChannelParameters ; const NAME : & 'static str = "ChannelParametersReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ChannelParametersReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } ParticipantsReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; BytesReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Debug , Default)] pub struct ChannelParametersBuilder { pub (crate) participants : Participants , pub (crate) nonce : Bytes , } impl ChannelParametersBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn participants (mut self , v : Participants) -> Self { self . participants = v ; self } pub fn nonce (mut self , v : Bytes) -> Self { self . nonce = v ; self } } impl molecule :: prelude :: Builder for ChannelParametersBuilder { type Entity = ChannelParameters ; const NAME : & 'static str = "ChannelParametersBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . participants . as_slice () . len () + self . nonce . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . participants . as_slice () . len () ; offsets . push (total_size) ; total_size += self . nonce . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . participants . as_slice ()) ? ; writer . write_all (self . nonce . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ChannelParameters :: new_unchecked (inner . into ()) } }
